> 参考文献
>
> 1. <https://webpack.github.io/>
> 2. <https://webpack.docschina.org/>

# 一、概述

![](IMGS/webpack-des.png)



本质上，*webpack* 是一个现代 JavaScript 应用程序的 静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个[依赖关系图(dependency graph)](https://webpack.docschina.org/concepts/dependency-graph/)，其中包含应用程序需要的每个[模块](https://webpack.docschina.org/concepts/modules/)，然后将所有这些模块打包成一个或多个 bundle。

从图中我们可以看出，*Webpack* 可以将多种静态资源 js、css、less 转换成一个静态文件，减少了页面的请求。

## 1. 什么是webpack？

> WebPack可以看做是**模块打包机**：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。

这段话有三个重点：

- 打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。
- 转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。
- 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。

## 2. 为什么需要webpack？

现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SASS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。

现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。

- React.js     + WebPack
- Vue.js        + WebPack
- AngluarJS + WebPack


## 3. 模块化

随着网站内容越来越复杂，浏览器和用户的交互越来越细腻，网站再也不是简单的内容呈现，更像是一个复杂的客户端软件，其中html/css/js代码越来越多，逻辑越来越复杂，越来越不便于管理，为了解决这个问题，才出现了模块化的概念，也就是说模块化更多的是工程方面的产出，为了应对更复杂的网站开发。

模块化是一种处理复杂系统分解为更好的可管理模块的方式。简单来说就是解耦，简化开发，一个模块就是实现特定功能的文件，可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范。

模块化，让我们可以把复杂的程序细化为小的文件;类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能转换为JavaScript文件使浏览器可以识别；

这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别，而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。

### 3.1. 模块化有哪些优点？

- 可以兼容多模块风格，无痛迁移老项目。
-  一切皆模块，js/css/图片/字体都是模块。
-  静态解析，按需打包，动态加载。

### 3.2. 模块化规范

#### 3.2.1. [commonJS 规范](http://www.commonjs.org/specs/modules/1.0/) *

CommonJS就是一个JavaScript模块化的规范，是用在服务器端的node的模块规范，前端的webpack也是对CommonJS原生支持的。

> a. 特点：

- 模块输出的是一个值的拷贝， 模块是运行时加载，同步加载
- CommonJS 模块的顶层 `this` 指向当前模块

> b. API：

- require：加载所要依赖的其他模块
- module.exports 或者exports：对外暴露的接口

> c. 示例：新建两个模块 A.js、B.js

```javascript
// A.js
// writing one:
let a = 10, b = 20;
module.exports = { a, b };

// writing two:
module.exports.a = 10;
module.exports.b = 20;

// writing three:
exports.a = 10;
exports.b = 20;

// 三种写法结果是一样，对外暴露的接口的结果是一致的
```

```javascript
// B.js
const A = require("./A");
A  // {a:10, b:20}
```

注意：

1. exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象，module.exports 可以直接赋值。

2. 一个文件不能写多个module.exports ，如果写多个，对外暴露的接口是最后一个module.exports。

3. 模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象。

#### 3.2.2. ES6 *

ES6 在语言标准的层面上，实现了模块功能，而且非常简单，ES6到来，完全可以取代 CommonJS 和AMD规范，成为浏览器和服务器通用的模块解决方案。

> a. 特点：

- ES6 模块之中，顶层的`this`指向`undefined`，即不应该在顶层代码使用`this`。
- 自动采用严格模式"use strict"。须遵循严格模式的要求
- ES6 模块export、import命令可以出现在模块的任何位置，但是必须处于模块顶层。如果处于块级作用域内，就会报错
- ES6 模块输出的是值的引用

> b. API

[import](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import)：加载所要依赖的其他模块

[export](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export)：对外暴露的接口

> 示例

```js
// 1. 导出单个属性
export const a = 10;
export const b = 20;
import {a, b} from "./path"
// 2. 导出属性列表
const a = 10, b = 20;
export {a, b}
import {a, b} from "./path"
// 3. 重命名导出
export {a as x, b as y }
import {x, y} from "./path"
// 4. 默认导出
export default { min:10, max:20 }
import 变量 from "./path"
```

#### 3.2.3. AMD

AMD 即 Asynchronous  Module  Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，所以AMD规范的实现，就是require.js了

> a. 特点：

异步加载，不阻塞页面的加载，能并行加载多个模块，但是不能按需加载，必须提前加载所需依赖。

> b. API：

```javascript
// 1.定义声明模块，参数id 模块id标识(可选)，参数二是一个数组（可选），依赖其他模块，最后是回调函数
define(id?,[]?,callbakc)
// 2.加载模块，参数一，是数组，指定加载的模块，参数二回调函数，模块加载完成后执行
require([module],callback)
```

还有一个配置属性API：

```javascript
require.config({

	baseUrl: // 基本路径

	paths： // 对象，对外加载的模块名称  ： 键值关系，键：自定义模块名称，值 ：文件名或者文件路径(不要写文件后缀.js),可以是字符串，数组（如果第一个加载失败，会加载第二个）

	shim： // 对象，配置非AMD 模式的文件，每个模块要定义（1）exports：值（指在js文件暴露出来的全局变量，如：window.a）（2）deps： 数组，表明该模块的依赖性
})
```

注意：paths 的设置加载优化与shim 中配置(AMD模式优先非AMD模式)

> c. 示例：加载不同情况的(非AMD 模式，AMD 模式)的例子

示例1：加载AMD模式模块

```html
<!-- 首先，引入requiresJS -->
<!-- requirejs.html -->
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title></title>
        <!--data-main ：
			设置data-main属性,设置加载主文件路径,默认设置该目录为根目录 
			如：../js/index.js ,默认把 ../js 作为模块文件的根模块 -->
        <script src="../js/require.js" data-main="../js/index.js"  defer async="async" type="text/javascript"></script>
    </head>
</html>
```

```javascript
// Math.js
// 定义了AMD 模式的模块,并且引入了jquery 模块 （这里的jquery属于AMD模式）
define(['jquery'],function(_){
    // define(['moudel1','moudel2'],callback())
    // 如果一个模块不依赖其他模块,直接使用define()函数写，
    // 如果一个模块依赖其他模块,define()第一个参数是数组
    // 回调函数的参数对应第一个参数数组的值，按顺序
   console.log(_);//ƒ (a,b){return new m.fn.init(a,b)}
　　return { 
        add:function(x,y){
            return x + y;
        },
    }
})
```

```javascript
// index.js (主入口)
// 配置好加载路径
require.config({
    baseUrl:"../js",
    paths:{    
        "index":"index", // 主入口文件 index: 
　　　　　"jquery":"jquery.min",// jquery 库，符合AMD模式(1.7 版本以上符合AMD)
        "maths":"Math", //自定义AMD 模式的模块
    }
})

// 加载maths.js
require(["maths"],function(_math){
    console.log( _math); // {add: ƒ }
})
```

示例2：加载非AMD 模式的模块，依赖非AMD模块 ，第三方插件（如jquery .lazyload 插件）

这里用到了shim属性配置(加载非AMD 模式)

```javascript
// index.js (主入口)
// 配置好加载路径
require.config({
    baseUrl:"../js",
    paths:{    
        "index":"index", // 主入口文件 index: 
        "jquery":"jquery.min",//jquery 库(1.7 版本以上符合AMD)
        "jquery.lazyload": [ // 非AMD 模式 依赖jquery 库的第三方插件
    　      　"http://apps.bdimg.com/libs/jquery-lazyload/1.9.5/jquery.lazyload.min",
　　　　　     "jquery.lazyload"
　　　　　　],
  　　　　 //这里加载了百度静态资源cdn和本地的资源(如果第一个加载失败，会加载本地)}，
    },
    shim:{
        "jquery.lazyload":{ 
            deps:["jquery"] //配置 jquery 依赖
        }
    }
});
// 加载jquery 和jquery.lazyload
require(["jquery","jquery.lazyload"],function($){
    $("img.lazy").lazyload({effect: "fadeIn"});
})
```

示例3：加载非AMD 模式 (闭包形式)的模块，有依赖（非AMD模式）,自定义（与示例2，差不多）

指定了config 配置的 shim 中exports属性，有返回值

```javascript
// util.js,
// 非闭包，暴露了两个全局变量 utils ,obj
var utils = {};  
var obj   = {};
utils.add = function(v1,v2){  
    return v1+v2;  
}; 
obj.reduce = function(x,y){
    return x-y;
}
// test1.js
// 非AMD 模式的 (闭包形式)，一般插件写法，使用wondow 对外暴露了objTest 变量
(function(window,$,obj,utils){
    console.log($);//ƒ (a,b){return new m.fn.init(a,b)}
    console.log(utils);//{add: ƒ}
    console.log(obj);//{reduce: ƒ}
    window.objTest = {};//window等于对外暴露接口
    
})(window,jQuery,obj,utils)//  只能写接口$或者 jQuery(不能写AMD 的模块名称jquery,会报错undefined)

// index.js (主入口)
// 配置好加载路径
 require.config({
    baseUrl:"../js",
    paths:{    
        "index":"index", // 主入口文件 index: 
        "jquery":"jquery.min",//jquery 库(1.7 版本以上符合AMD)
    },
　　shim:{
   　　 "test1":{// 非AMD 模式的(闭包形式)
            deps:["util"],//设置依赖util:实际是,加载 了 "../js/util.js" 依赖该js 中的所有全局变量
            exports:"objTest" , //在test1.js 文件中，使用了window.objTest 对外暴露了接口
        },
    　　"util":{ // 非AMD 模式  (非闭包)
            deps:["jquery"],//设置依赖
        }
    }
})
// 加载 test1.js
require(["test1"],function(_){
    console.log(_);//返回的是一个对象 {},因为在配置中设置了exports
    console.log("load finshing...")
});
```

```javascript
//加载 util.js
require(["util"],function(_){
    console.log(_);//返回的是一个undefind,没有配置exports
    console.log("load finshing...")
});
```

分析示例3：在 test1.js 中，闭包函数，一共传了四个值，分别是  window,jQuery,obj,utils ,

window 就不用说了，jQuery 从哪里传来呢？index.js 主文件中的shim 中test1 模块的依赖只有util （等于加载了util.js 文件，依赖了该文件中的所有全局变量，obj 和utils）; 回归jQuery 从哪里加载进来，别忘paths 的配置加载优先shim 配置，所以先加载了paths 中的jquery 模块，即使jquery 也是支持AMD ，但是也是暴露了window.jQuery 全局变量，所以后于jquery 模块的加载，无论是AMD 还是非AMD 都可以得到该全局变量jQuery

注意 ：非AMD 模块中依赖AMD 模块，是不可以直接在deps属性中设置AMD的模块名作为依赖，这样是直接报错的

#### 3.2.4. CMD

CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。

玉伯说过能够亲眼看到seajs死掉也是一种幸福(说明了什么，你懂的)

```javascript
seajs.config({
    // 设置别名，方便调用
    alias: { 'jquery': 'http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js' }
});

define(function(require, exports, module) {
    // 引用jQuery模块
    var $ = require('jquery');
});

// 加载多个模块，在加载完成时，执行回调
seajs.use(['./a', './b'], function(a, b) {
    a.doSomething();
    b.doSomething();
});
```

# 二、初探 

## 1. 准备

首先你需要创建项目，并在终端进入到该项目目录中，通过 `npm` 或 `yarn` 生成 *package.json* 配置文件。

```shell
$ npm init -y
OR
$ yarn init -y 
```

## 2. 安装

安装 `webpack` 及其命令行工具 `cli`：

```shell
$ npm i -D webpack webpack-cli
OR
$ yarn add -D webpack webpack-cli
# 查看版本
$ ./node_modules/.bin/webpack -v
4.39.3
```

## 3. 创建项目结构

接下来创建如下项目结构：

```
.
├── dist
    └── index.html
├── node_modules
├── package.json
└── src
    └── js
    	├── main.js
   		├── util.js
```

>  提示：
>
>  1. src是源码文件，dist是我们编译打包好的文件；一个用于**开发环境**，一个用于**生产环境**。
>  2. node_modules 为 yarn 或 npm 安装依赖时自动生成的文件。

## 4. 编辑项目文件

-> index.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>webpack example</title>
</head>
<body>
		<h1 id="title"></h1>
    <!-- 引入webpack打包后生成的文件 -->
    <script src="./static/js/main-bundle.js"></script>
</body>
</html>
```
-> util.js

```javascript
class Util {
    constructor() {}
    static setTitle(id, title) {
        let el = document.getElementById(id);
        el.textContent = title;
    }
}

module.exports  = {
    Util
}
```
-> main.js
```javascript
import {Util} from "./util";
Util.setTitle("title", "Hello, webpack!");
```

## 5. 创建配置文件 

webpack.config.js 就是Webpack的配置文件，这个文件需要自己在**项目根目录下**手动建立。建立好后我们对其进行配置，先看下面的代码（ webpack.config.js 的基本结构），这是一个没有内容的标准webpack配置模版。

```javascript
module.exports={
  	// 指定打包模式(development|product)，必须设置，否则抛出警告
  	// development：开发者模式 -> 不压缩编译之后的文件
  	// product：生产模式 -> 压缩编译之后的文件
  	mode: "development",
    // 入口文件的配置项，可以是单一入口，也可以是多入口。
    entry:{},
    // 出口文件的配置项
    output:{},
    // 配置加载器
    module:{},
    // 配置插件
    plugins:[],
    // 配置w开发服务功能
    devServer:{}
}
```

接下来我们对 “webpack.config.js” 文件进行简单配置：

```javascript
// 引入webpack
const webpack = require("webpack");
// 引入node 路径
const path    = require("path");

module.exports = {
    // 配置基础路径为当前目录（默认为配置文件所在的当前目录）
    context: path.resolve(__dirname, './'),
    // 指定打包模式
    "mode":"development",
    // 配置入口文件
    entry: {
        "main": "./src/js/main.js"
    },
    // 配置出口文件
    output: {
        // 所有输出文件的目标路径，必须是绝对路径（使用 Node.js 的 path 模块）
        path: path.resolve(__dirname, "./dist/"),
        // 输出文件名
        filename: "static/js/[name]-bundle.js"
    }
};
```

## 6. 编译打包

```shell
$ ./node_modules/.bin/webpack 
Hash: 15e30d9fcca998c8ef47
Version: webpack 4.39.3
Time: 89ms
Built at: 2019-09-04 21:17:43
                   Asset      Size  Chunks             Chunk Names
static/js/main-bundle.js  4.64 KiB    main  [emitted]  main
Entrypoint main = static/js/main-bundle.js
[./src/js/main.js] 71 bytes {main} [built]
```

执行打包任务之后，会在 “./dist/static/js” 目录下生产一个  ”main-bundle.js“ 文件，运行 ”index.html“ 可以看到 ”Hello, webpack!“ 说明打包成功。

> 提示：你可以尝试不同的打包模式观察二者的区别。

## 7. 扩展知识

### 7.1. * 指定配置文件编译

在实际开发过程中，你可能会创建不同的config.js文件来满足不同的开发需求，比如你在开发阶段，通常会创建一个 “webpack.dev.config.js” 文件，那么你在执行编译指令的时候需要指向该配置文件，如下所示：

```shell
$ ./node_modules/.bin/webpack --config ./build/webpack.dev.config.js
Hash: 86801f3c9bf5c3223d39
Version: webpack 4.30.0
Time: 94ms
Built at: 2019-09-04 00:23:21
                   Asset      Size  Chunks             Chunk Names
static/js/main-bundle.js  4.65 KiB    main  [emitted]  main
Entrypoint main = static/js/main-bundle.js
[./src/js/main.js] 73 bytes {main} [built]
[./src/js/util.js] 186 bytes {main} [built]
```

> 提示：假设配置文件的路径是：*./build/webpack.dev.config.js*，那你需要在配置文件中做如下修改：
>
> ```js
> module.exports = {
>     context: path.resolve(__dirname, "../"),
>     output: {   
>         path: path.resolve(__dirname, "../dist/"),
>     }
> };
> ```

### 7.2. * 编译参数配置

webpack 自身提供了一些参数来优化编译任务，以下简单列出了一些参数：

| 参数                    | 描述                   |
| ----------------------- | ---------------------- |
| --config                | 指定配置文件           |
| --watch, -w             | 监听变动并自动打包     |
| -p                      | 压缩混淆脚本           |
| --progress              | 显示进度条             |
| --display-reasons       | 显示添加打包模块的原因 |
| --display-error-details | 出错时错误的详情       |

> 提示：想了解webpack更多参数，可在终端输入 `./node_modules/.bin/webpack -h`  查看

这里以监听为例，执行编译的时候带上 -w 参数，如下所示：

```shell
$ ./node_modules/.bin/webpack --config ./build/webpack.dev.config.js  -w
```

当你对文件做了任何修改都会进行自动编译，如果你想要取消监听状态，可使用快捷键：`CTR/CMD+C`

### 7.3. * 简化指令

可以发现，如果执行编译任务，特别是在参数比较多的情况，是比较麻烦的，我们可以在 npm 的 ”package.json“ 文件中进行添加一个脚本指令的字段，如下所示：

```json
"scripts": {
  "build":"./node_modules/.bin/webpack --colors --progress --display-modules --display-reasons --display-error-details -w"
},
```

在 ”package.json“ 文件中配置添加完脚本配置之后，我们可直接通过如下令执行打包任务，如下所示:

```shell
$ npm run build
OR
$ yarn run build
```

至此，你已经初步了解了webpack的基本使用及webpack模块化思想。

# 三、核心

## 1. Entry

`Entry`：入口起点(entry point)，指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。

入口文件常用的配置形式如下：

```js
module.exports {
    entry: {
        "main": "./src/js/main.js",
        "news": "./src/js/news.js"  
    }
}
```

> 提示：在多页面项目中设置出口时，通过`[name]` 即可获取文件名，其中文件名就是入口设置中的 `key` 项。

## 2. Output

`Output`：该属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程。

出口文件常用的配置形式如下：

```javascript
module.exports {
	output: {
      // 输出目录
  		path: path.resolve(__dirname, "./dist/"),
  		// 输出文件名
  		filename: "static/js/[name]-bundle.js",
  		// 处理静态资源路径
  		// 静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径
  		// 这里假设开启devServer服务
  		publicPath: "http://localhost:8080/"
    }
}
```

- `[name]`：模块名称，也就是在指定入口时的 `key` 值。
- `[hash]`：打包后文件的 hash 值，md5，保证文件唯一性。
- `[chunkhash]`：模块自身的hash值。

## 3. Loader

webpack 只能理解 JavaScript 和 JSON 文件。**loader** 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 [模块](https://webpack.docschina.org/concepts/modules)，以供应用程序使用，以及被添加到依赖图中。Loader 需要单独安装并且需要在 “webpack.config.js” 中的 `module` 关键字下进行配置，Loader 的配置包括以下几方面：

- `test`：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的；
- `use`：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错；
- `include/exclude`：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；

### 3.1. [babel-loader](https://www.npmjs.com/package/babel-loader)

**> 概述：**

通常用于将ES6转换为ES5的语法。

**> 安装：**

```shell
$ npm i -D babel-loader @babel/core @babel/preset-env
or
$ yarn add -D babel-loader @babel/core @babel/preset-env
```

**> 配置：**

```javascript
module: {
    rules: [
        // es6 -> es5
        {
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
                loader: "babel-loader",
                options: {
                    presets: ["@babel/preset-env"]
                }
            }
        }
    ]
}
```

### 3.2. 样式相关

**\> 概述：**

- [css-loader](https://www.npmjs.com/package/css-loader)：使你能够使用类似 `import` 和 `url()`  的方法实现  `require()` 的功能。

- [style-loader](https://www.npmjs.com/package/style-loader)：将所有计算后的样式加入页面中

- [less-loader](https://www.npmjs.com/package/less-loader)：编译LESS

- [sass-loader](https://www.npmjs.com/package/sass-loader)：编译SASS

- [postcss-loader](https://www.npmjs.com/package/postcss-loader)：添加浏览器前缀（该loader还有其他额外的功能）

**> 安装：**

```
$ npm i -D css-loader style-loader less less-loader postcss-loader autoprefixer
```

**\> 配置：**

自动添加前缀（autoprefixer）指定兼容版本需在 “package.json”中的“browserslist”字段中配置即可：

```json
"browserslist": [
  "last 2 version"
]
```

```js
{
    test: /\.less$/,
    exclude: /node_modules/,
    use: ["style-loader", "css-loader", {
        loader: "postcss-loader",
        options: {
            ident: "postcss",
            plugins: [require("autoprefixer")]
        }
    }, "less-loader"]
}
```

> 注意：引用顺序为从右到左，样式引入使用 commonJS规范引入。如果需要分离CSS文件，可使用插件 [extract-text-webpack-plugin](https://www.npmjs.com/package/extract-text-webpack-plugin) 。

### 3.3. [file-loader](https://www.npmjs.com/package/file-loader)、[url-loader](https://www.npmjs.com/package/url-loader)

**> 概述：**

- file-loader：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。
- url-loader：如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。

**> 安装：**

```shell
$ npm i -D file-loader url-loader
or
$ yarn add -D file-loader url-loader
```

**> 配置：**

> url-loader 配置：

```javascript
{
      test: /\.(png|jpg|jpeg|gif)$/,
      exclude: /node_modules/,
      use: {
          loader: "url-loader",
          options: {
              limit: "1024",
              name: "[name].[ext]",
              outputPath: "static/images/"
          }
      }
}
```

为什么只使用url-loader?

有的小伙伴会发现我们并没有在webpack.config.js中使用file-loader，但是依然打包成功了。我们需要了解file-loader和url-loader的关系。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况：

1.文件大小**小于**limit参数，url-loader将会把文件转为DataURL（Base64格式）；

2.文件大小**大于**limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。

也就是说，其实我们只安装一个url-loader就可以了。但是为了以后的操作方便，我们这里就顺便安装上file-loader。

> file-loader配置：

使用file-loader输出图片

```javascript
{
    test: /\.(png|jpg|jpeg|gif)$/,
    exclude: /node_modules/,
    use: {
        loader: "file-loader",
        options: {
            // 指定输出文件名字
            name: "[name]-[hash:6].[ext]",
            // 指定输出文件路径（相对于出口路径）
            outputPath:"static/images/",
            // 指定图片引用路径前缀
            publicPath: "../images/"
        }
    }
}
```

### 3.4. [html-loader](https://www.npmjs.com/package/html-loader)

**>  概述：**

webpack处理资源无往不利，但有个问题总是很苦恼，html中直接使用img标签src加载图片的话，因为没有被依赖，图片将不会被打包。这两个loader都可以解决这个问题，图片会被打包，而且路径也处理妥当。额外提供html的include子页面功能。

**> 安装：**

```shell
# NPM
$ npm i -D html-loader
# YARN
$ yarn add -D html-loader
```

> 提示：任选一个安装

**> 配置：

```javascript
{
    test: /\.html/,
    exclude: /node_modules/,
    loader: 'html-loader'
}
```

## 4. Plugins

插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。
Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的，一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程起作用。

Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。

要使用某个插件，我们需要通过 npm  或者 yarn 安装它，然后要做的就是在webpack配置中的**plugins**关键字部分添加该插件的一个实例（plugins是一个数组）。

### 4.1. [webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)

**\> 概述**

该插件是将打包后的内容用canvas以图形的方式展示出来，借助这个工具，我们可以知道每个chunk由哪些模块组成，非常方便好用

**\> 安装**

```shell
# NPM 
npm install --save-dev webpack-bundle-analyzer
# Yarn 
yarn add -D webpack-bundle-analyzer
```

**\> 配置**

```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
 
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin()
  ]
}
```

### 4.2. [Html-Webpack-Plugin](https://www.npmjs.com/package/html-webpack-plugin)

**> 概述**

HtmlWebpackPlugin 简化了HTML文件的创建，以便为你的webpack包提供服务，它可以自动为你生成项目中的html文件。 这对于在文件名中包含哈希的webpack bundle尤其有用，其主要作用如下：

- 为html文件中引入的外部资源如 script、link 动态添加每次compile后的hash，防止引用缓存的外部文件问题。
- 可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置**N**个 html-webpack-plugin 可以生成**N**个页面入口

插件的基本作用就是生成html文件，其原理主要是将 webpack中 entry 配置的相关入口thunk  和  extract-text-webpack-plugin 抽取的css**样式插入到该插件提供的** template 或者 templateContent 配置项指定的内容基础上生成一个html文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。

**> 安装**

```shell
# NPM
$ npm i --save-dev html-webpack-plugin
# YARN
$ yarn add --dev html-webpack-plugin
```

**> 配置**

```javascript
// 引入模块
const HtmlWebpackPlugin = require("html-webpack-plugin");
module.exports={
	plugins: [
           new HtmlWebpackPlugin({
            // 模板文件
            template: "./src/index.html",
            // 网页标题
            title: "主页",  
            // 文件名(相对于output.path)
            filename: "index.html",
            // 静态资源位置
            inject: "body",
            // 是否hash
            hash: true,
            // 指定输出文件所依赖的入口文件（*.js）的[name]
            chunks: ["main"]
        })
    ]
};
```



> 提示：
>
> 1. filename配置的html文件目录是相对于webpackConfig.output.path路径而言的，不是相对于当前项目目录结构的。
> 2. 指定生成的html文件内容中的 `link` 和 `script` 路径是相对于生成目录下的，写路径的时候请写生成目录下的相对路径。

### 4.3. [clean-webpack-plugin](https://www.npmjs.com/package/clean-webpack-plugin)

**> 说明**

清除文件

**> 安装**

```shell
# NPM
$ npm install --save-dev clean-webpack-plugin
# YARN
$ yarn add -D clean-webpack-plugin 
```

**> 配置**

```javascript
const { CleanWebpackPlugin } = require('clean-webpack-plugin');
 
const webpackConfig = {
    plugins: [
        new CleanWebpackPlugin(),
    ],
};
```

> 注意：名字中的 `C` 字母必须大写。

### 4.4. [BannerPlugin](https://webpack.docschina.org/plugins/banner-plugin)

**> 说明**

添加版权声明

**> 安装**

无需安装，该插件为 webpack 内置插件，直接使用即可。

**> 配置 **

```js
const webpack = require('webpack');
module.exports = {
    plugins: [
        new webpack.BannerPlugin("版权所有，翻版必究！")
    ]
};
```

![](IMGS/webpack-bannerPlugin.png)

### 4.5. [extract-text-webpack-plugin](https://www.npmjs.com/package/extract-text-webpack-plugin)

**> 概述：**

通过webpack 打包的样式被嵌入到了 bundle.js 文件中，如果你想要将其抽离出来，我们可以使用该插件。

**> 安装：**

```shell
# NPM
$ npm  install --save-dev extract-text-webpack-plugin@next
# YARN
$ yarn add --save-dev extract-text-webpack-plugin@next
```

> 提示：在webpack 4.x 中需指定@next版本，即beta版本。

**> 配置：**

```javascript
// module
{
    test: /\.less$/,
    exclude: /node_modules/,
    use: ExtractTextPlugin.extract({
        fallback: "style-loader",
        use: ["css-loader", {
            loader: "postcss-loader",
            options: {
                ident: "postcss",
                plugins: [
                    require("autoprefixer")
                ]
            }
        }, "less-loader"]
    })
}
// plugins
new ExtractTextPlugin("static/css/[name].css")
```

> 提示：输出路径相对于 output.path 设置

### 4.6. [uglifyjs-webpack-plugin](https://www.npmjs.com/package/uglifyjs-webpack-plugin)

**\> 概述：**

该插件主要用于压缩js

**\> 安装：**

```shell
$ npm i -D uglifyjs-webpack-plugin
or
$ yarn add -D uglifyjs-webpack-plugin
```

**\> 配置：**

```javascript
const UglifyJsPlugin = require("uglifyjs-webpack-plugin");
module.exoports = {
    optimization: {
        minimizer: [
            // 丑化JS
            new UglifyJsPlugin({
                test: /\.js$/,
                exclude: /node_modules/,
                uglifyOptions: {
                    // 是否压缩
                    compress: true
                }
            })
        ]
    }
}
```

### 4.7. [purifycss-webpack](https://www.npmjs.com/package/purifycss-webpack)

**> 概述：**

消除未使用的CSS。该插件必须配合  ”extract-text-webpack-plugin“ 插件使用，否则无效。

**> 安装：**

```shell
# NPM
$ npm i -D purifycss-webpack purify-css
# YARN
$ yarn add -D purifycss-webpack purify-css
```

**> 配置：**

```javascript
const glob = require('glob');
const PurifyCSSPlugin = require('purifycss-webpack');

// plugins
new PurifyCSSPlugin({
    // Give paths to parse for rules. These should be absolute!
    paths: glob.sync(path.join(__dirname, "./src/**/*.html")),
}),
```

这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。

配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。

### 4.8. [optimize-css-assets-webpack-plugin](https://www.npmjs.com/package/optimize-css-assets-webpack-plugin)

**\> 概述：**

压缩CSS

**\> 安装：**

```shell
$ npm install --save-dev optimize-css-assets-webpack-plugin cssnano
```

**\> 配置：**

```javascript
const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');

new OptimizeCssAssetsPlugin({
    assetNameRegExp: /\.css$/g,
    cssProcessor: require('cssnano'),
    cssProcessorPluginOptions: {
        preset: ['default', { discardComments: { removeAll: true } }],
    },
    canPrint: true
})
```

### 4.9. [copy-webpack-plugin](https://www.npmjs.com/package/copy-webpack-plugin)

**> 概述：**

工作中会有一些已经存在但在项目中没有引用的图片资源或者其他静态资源（比如设计图、开发文档），这些静态资源有可能是文档，也有可能是一些额外的图片。项目组长会要求你打包时保留这些静态资源，直接打包到指定文件夹。其实打包这些资源只需要用到copy-webpack-plugin。

**\> 安装：**

```shell
# NPM
$ npm i -D copy-webpack-plugin
# YARN
$ yarn add -D copy-webpack-plugin
```

**\> 配置：**

```js
const CopyPlugin = require("copy-webpack-plugin");

new CopyPlugin([
    {
        from: "./src/README.md",
        to: "./"
    }
])
```

- from：要打包的静态资源目录地址
- to：要打包到的文件夹路径，跟随output配置中的目录。

# 四、延伸

## 1. 热替换

[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server) 为你提供了一个简单的 web server，并且具有 live reloading（实时重新加载） 功能。安装方式如下：

```shell
$ npm i -D  webpack-dev-server
OR
$ yarn add -D  webpack-dev-server
```

devServer常用配置项如下，更多配置可参考 [这里](https://webpack.docschina.org/configuration/dev-server) 。

| 配置选项           | 功能描述                                                     |
| ------------------ | ------------------------------------------------------------ |
| contentBase        | 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“dist"目录） |
| port               | 设置默认监听端口，如果省略，默认为”8080“                     |
| inline             | 自动刷新页面                                                 |
| historyApiFallback | 处理404                                                      |
| host               | 设置服务器主机号，在开发阶段，一般设置为：localhost          |
| proxy              | 设置代理                                                     |

devServer 配置如下：

```javascript
devServer: {
    contentBase:path.resolve(__dirname,"./dist/"),
    host: "localhost",
    port: 8090,
    open: true,
    inline: true,
    hot: true // 热替换
}
```

要实现热替换，还需调用插件。在热替换（HMR）机制里，不是重载整个页面，HMR程序会只加载被更新的那一部分模块，然后将其注入到运行中的APP中。

```js
plugins: [
    new webpack.HotModuleReplacementPlugin()
]
```

在 “package.json” 中添加如下命令，可以开启本地服务器：

```javascript
{
	"scripts": {
    	"dev": "./node_modules/.bin/webpack-dev-server"
	}
}
```

在终端中输入`npm run dev` 或 `yarn eun dev `即可在本地的 `8090` 端口查看结果。



> 注意：
>
> 1、webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中，然后将它们 serve 到 server 中，就好像它们是挂载在 server 根路径上的真实文件一样。如果你的页面希望在其他不同路径中找到 bundle 文件，则可以通过 dev server 配置中的 [`publicPath`](https://webpack.docschina.org/configuration/dev-server/#devserver-publicpath-) 选项进行修改。
>
> 2、如果你自定义了配置文件，如 “webpack.dev.config.js”，那么在执行devServer的时候，也要指定相应的配置文件，如：webpack-dev-server --config webpack.dev.config.js。
>
> 3、在开发阶段，我们可以通过设置 “output” 中的 “publicPath” 字段访问静态资源，以刚刚配置devServer为例，我们可以在“output”出口设置中添加如下字段：*publicPath: "http://localhost:8090/"*，此时，你静态资源的访问路径将会变成：publicPath + 静态资源地址，待项目上线之后，再将publicPath设置为线上地址即可。

## 2. contxt

上下文，基础目录，**绝对路径**，用于从配置中解析入口起点和 loader，入口起点会相对于此目录查找。默认为当前目录，即配置文件所在的目录，所以一般当自定义配置文件之后，我们需要设置该属性，比如配置文件放在在 ”./build“ 目录中，则上下文配置如下：

```js
context: path.resolve(__dirname, "../");
```

## 3. 处理静态资源路径

以处理图片为例，首先安装Loader

```shell
$ npm i -D file-loader html-loader
```

- file-loader：处理图片
- html-loader：处理\<img src>引入的图片

然后对两个loader进行配置：

```js
// 处理图片
{
    test: /\.(jpg|jpeg|svg|png)$/,
    exclude: /node_modules/,
    use: {
        loader: "file-loader",
        options: {
            name: "[name]-[hash:6].[ext]",
            outputPath: "static/images/"
        }
    }
},
// 处理HTML
{
    test: /\.html$/,
    exclude: /node_modules/,
    loader: 'html-loader'
}
```

最后在webpack.config.js文件的output选项中设置publicPath，主要作用就是处理静态文件路径的。

```javascript
output: {
    filename: "js/bundle.js",
    path: path.resolve(__dirname, "./dist"),
    publicPath: "http://localhost:8080/"
},
```

注意，这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。

配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。

## 4. 资源映射

```javascript
module.exports = {
	devtool: 'eval-source-map'
}
```

总结：调试在开发中也是必不可少的，但是一定要记得在上线前一定要修改webpack配置，在打出上线包。

## 5. 引用三方库

### 5.1. 直接引入

```js
import $ from 'jquery';
```

### 5.2. 全局引入

```js
new webpack.ProvidePlugin({
	$:"jquery"
})
```

## 6. watch的正确使用方法

在初级开发阶段，使用webpack-dev-server就可以充当服务器和完成打包任务，但是随着你项目的进一步完成，可能需要前后台联调或者两个前端合并代码时，就需要一个公共的服务器了。这时候我们每次保存后手动打包显然效率太低，我们希望的场景是代码发生变化后，只要保存，webpack自动为我们进行打包。这个工具就是watch，这节课我们把wacht完全学会，你会发现在开发中更加的得心应手。

**\> watch的配置**

很多小伙伴认为–watch直接使用就可以，并没有什么需要讲的。其实这只是初级的用法，但是在学习一种技术时，我们必须要做到了解全部，也就是常说的知其然知其所以然。我们看下面的配置代码，我在代码中已经做出了解释。

```javascript
watchOptions:{
    // 检测修改的时间，以毫秒为单位
    poll:1000, 
    // 防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作
    aggregateTimeout:500, 
    // 不监听的目录
    ignored:/node_modules/, 
}
```

上边的每一行配置我都作了说明，有时候你在没配置的情况下，直接用webpack –watch是不起作用的，这时候你需要进行配置这些选项。

配置好后，我们就可以痛快的使用watch了，在大型项目中，这大大加快了我们的开发效率，不用反复的手动打包了。

## 7. 解析

有时候我们不想路径暴露出去，可以使用取别名的形式：

```javascript
moudle.exports = {
  resolve: {
        // 创建别名
        alias: {
            "main-less": path.resolve(__dirname, './src/less/main.less'),
            "font-icon": "font-awesome/css/font-awesome.css"
        }
    }
}
```

这样在需要引入对应插件的时候，直接使用即可：

```js
require("normalize-css");
require("font-icon");
```

## 6. 抽离公共文件

当一部分代码需要反复被用到，反复请求浪费资源，将公共代码 抽离，需要时读取缓存即可

```js
output: {
  ...
  chunkFilename: "[name].chunk.js"
}
optimization: {
    splitChunks: {
        cacheGroups: {// 缓存组，缓存公共代码
            // 首先：打包node_modules中的文件
            vendor: {
                test: /node_modules/,
                name: "vendor",
                minSize: 0, 
                minChunks: 1,
                chunks: "all",
                priority: 1 
            },
            // 其次: 打包业务中公共代码
            common: {
                name: "common",
                chunks: "all",  
                minSize: 0,      
                minChunks: 2,   
                priority:0
            }
        }
    }
}
```

# 五、注意

- 一旦修改了webpack的配置文件，必须重启服务或重新build。否则失效。
- 如果自定义配置文件，切记在执行打包时一定要指定配置文件路径























